# 标题：移动语义



# 1、lvalue和rvalue

- 每个表达式的返回值不是左值就是右值

- 左值：

  - 被计算为一个持续存在的值，其内存地址可以被用来持续存储值
  - 通常出现在赋值运算符的左边

- 右值：

  - 被计算为一个暂时存储的结果
  - 只能出现在表达式右边

- 左值和右值是对表达式的分类，不是对值的分类

- 大部分函数调用表达式都是右值，除非返回引用的函数，如数据的下标函数

  ```c++
  v[1] = 1;
  v.at(1) = 1;
  ```

- 判断左值还是右值：如果表达式的结果可以长久存在，可以获取并使用该地址，就是左值。

- 所有数值字面量都是右值，编译器不允许获取数值字面量的地址。



## 右值 引用

- 存在左值和右值引用
- 左值引用是另一个变量的别名，另外C++允许const T& 类型的变量，绑定临时的右值
- 右值引用也是变量的别名，与左值引用不同的是，它可以引用一个右值表达式的结果。引用后，就可以延时该临时值的生命周期。
- 使用T&& ，双&来表明为右值引用。





# 2、移动对象

- 例子：有一个基础数据d1，多种处理方法f1、f2、f3....等，需要将D1处理的结果使用数组v保存下来。

  无优化函数

  ```rust
  for func in {f1,f2,f3....} {
      v.push( func(d1) ); // 每次传入都会复制
  }
  ```

  

## 传统方法

- 使用输出参数，即函数的实参将作为返回值来使用。

  ```C++
  void func(T& out){}
  ```

  ```rust
  for func in {f1,f2,f3....} {
      D d1;
      func(d1);
      v.push( d1 ); 
  }
  ```

  还需进一步优化，不需要考虑这种做法了

- 使用智能指针，但类型名长，且需要使用->和*来操作数据



## 定义移动成员

### 1、移动构造函数

